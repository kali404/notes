# 美多后台概述

## 大概模式

我们这个项目是一个B2C模式的电商网站

后端采用了前后端分离的开发模式

我主要负责是整个项目的后端管理页面开发

前端采用vue框架

后端采用Django REST framework

主要实现功能有:管理员登陆,数据统计,用户管理,商品管理,订单管理,用户权限管理

主要技术有:JWT用户认证,CORs跨域

## 同源策略

在管理员登陆模块时:

​	由于浏览器的同**同源策略**,

> 同源策略是浏览器的一个安全功能，不同源的客户端脚本(js文件)在没有明确授权的情况下，不能读写对方资源。只有同一个源的脚本赋予dom、读写cookie、session、ajax等操作的权限,两个url的协议、域名和端口相同，则这两个url是同源的

## CORS:跨域资源共享

由于我们的前段时使用的8080端口

后端则采用了8000端口

**前端与后端分别是不同的端口，这就涉及到跨域访问数据的问题，因为浏览器的同源策略，默认是不支持两个不同域名间相互访问数据，而我们需要在两个域名间相互传递数据，这时我们就要为后端添加跨域访问的支持。**

实现跨域资源共享的三种方式

* 关闭浏览器同源策略
* 在请求体加入Origin字段,由后端进行验证
* 在浏览器发起一次跨域请求时,第一次先发送options请求询问后端是否允许跨域，后端查询白名单中是否有这个域名,如果域名在白名单中则在响应结果中告知浏览器允许跨域

我们采用了第三种方式,采用了**django-cors-headers**扩展

## JWT用户验证机制

在用户注册或登录后，我们想记录用户的登录状态，或者为用户创建身份认证的凭证。我们不再使用Session认证机制，而使用Json Web Token认证机制。简称JWT

传统的**session认证**

* 认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。
* 分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力
* 容易受到跨站请求伪造的攻击。

基于**token的鉴权机制**

流程上是这样的：

- 使用用户名密码来请求服务器
- 服务器进行验证用户的信息
- 服务器通过验证发送给用户一个token
- 客户端存储token，并在每次请求时附送上这个token值
- 服务端验证token值，并返回数据

第一部分我们称它为头部（base64加密),

第二部分我们称其为载荷（base64加密)，

第三部分是签证（加盐组合加密).

### 优点

- 因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。
- 因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。
- 便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。
- 它不需要在服务端保存会话信息, 所以它易于应用的扩展

## 管理员登陆

Django REST framework JWT提供了登录签发JWT的视图，可以直接使用

JWT扩展的登录视图，在收到用户名与密码时，也是调用Django的认证系                                                                                    统中提供的**authenticate()**来检查用户名与密码是否正确。

**我们想要让管理员用户才能登录我们的admin后台,修改了django原有的用户验证方法。**

## 数据统计

* 用户总数统计
* 日增用户
* 日活跃用户
* 日下单用户
* 月增用户
* 下单用户
* 日分类商品访问量

由于在数据统计模块当中,只实现了统计和日期的查询,继承了rest_framework下的APIview

## 用户管理

只实现了查询用户和增加用户
使用了序列化器
我们继承了rest_framework下的子类ListAPIView

实现了用户的展示,和增加用户

实现了对用户的模糊搜索功能
重写get_queryset方法，根据前端是否传递keyword值返回不同查询结果

对于新增用户功能ModelSerializer自带的create方法不能满足我们在序列化器中重写了create方法

## 商品管理

* sku表管理

* spu表管理
* 规格表管理
* 图片表管理

实现了增删改查操作基本上继承了rest_framework下的ModelViewSet,

在sku表的保存和修改时需要嵌套返回规格信息表的数据所以需要在序列化器中嵌套返回sku表的规格信息

保存和修改时需要对两张表进行操作我们开启了**sql事务**

> - 在保存和修改商品数据时，涉及到多张表的数据修改，对这些数据的修改应该是一个整体事务，即要么一起成功，要么一起失败。
>
>   - 通过**django.db.transaction模块**提供的**atomic**来定义一个事务
>
>     
>
>     - 装饰器
>   - with 语句
>    
>   - 在事务中创建保存点来记录数据的特定状态，数据库出现错误时，可以回滚到数据保存点的状态
>   

而且对sku表格进行保存和修改时 需要开启**异步任务**,来防止耗时操作

> - 我们的代码是自上而下同步执行的。
> - 页面静态化是耗时的操作。如果静态化被阻塞住，用户响应将会延迟。
> - 解决方法是将静态化从主业务中解耦,从而提高用户体验



对图片表进行保存和修改操作时我们使用了**fastDFS**对图片进行修改和上传

> - FastDFS架构.包括 `Client`  ` Tracker server`   和 `Storage server`
>
>      - `Client`请求`Tracker`进行文件上传、下载，`Tracker`再调度`Storage`完成文件上传和下载。
>
>   - **Client**： 客户端，业务请求的发起方，通过专有接口，使用TCP/IP协议与`Tracker`或`Storage`进行数据交互。FastDFS提供了`upload`、`download`、`delete`等接口供客户端使用。
>
> - **Tracker server**：跟踪服务器，主要做调度工作，起负载均衡的作用。在内存中记录集群中所有存储组和存储服务器的状态信息，是客户端和数据服务器交互的枢纽。
>
> - Storage server
>
> 存储服务器（存储节点或数据服务器），文件和文件属性都保存到存储服务器上。Storage server直接利用OS的文件系统调用管理文件。
>
>   - Storage群中的**横向可以扩容，纵向可以备份**。



> 文件索引（file_id）信息包括：组名、虚拟磁盘路径、数据两级目录、文件名等信息。
>
> - **组名**：文件上传后所在的 Storage 组名称。
> - **虚拟磁盘路径**：Storage 配置的虚拟路径，与磁盘选项`store_path*`对应。如果配置了`store_path0`则是`M00`，如果配置了`store_path1`则是`M01`，以此类推。
> - **数据两级目录**：Storage 服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据文件。
> - **文件名**：由存储服务器根据特定信息生成，文件名包含:源存储服务器IP地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。

## 订单管理

基本上对表数据进行了增删改查操作

与商品管理类似同样继承了ModelViewSet

对于,订单详情页使用了多层序列化器进行返回

## 用户权限管理

- 消费者用户与公司内部运营用户使用一个用户数据库来存储
- 通过is_staff 来区分是运营用户还是消费者用户
- 对于运营用户通过is_superuser 来区分是运营平台的管理员还是运营平台的普通用户
- 对于运营平台的普通用户，通过权限、组和组外权限来控制这个用户在平台上可以操作的数据。
- 对于权限，Django会为每个数据库表提供增、删、改、查四种权限同样继承我们的ModelViewSet
- 用户最终的权限为 组权限 + 用户特有权限