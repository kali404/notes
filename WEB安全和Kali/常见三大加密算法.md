# 常见的三大加密算法
加密，是以某种特殊的算法改变原有的信息数据，使得未授权的用户即使获得了已加密的信息，但因不知解密的方法，仍然无法了解信息的内容。
加密建立在对信息进行数学编码和解码的基础上。加密类型分为两种，对称加密与非对称加密，对称加密双方采用共同密钥，（当然这个密钥是需要对外保密的），这里讲一下非对称加密，这种加密方式存在两个密钥，密钥 -- 一种是公共密钥（正如其名，这是一个可以公开的密钥值），一种是私人密钥（对外保密）。 您发送信息给我们时，使用公共密钥加密信息。 一旦我们收到您的加密信息，我们则使用私人密钥破译信息密码（被我们的公钥加密的信息，只有我们的唯一的私钥可以解密，这样，就在技术上保证了这封信只有我们才能解读——因为别人没有我们的私钥）。 使用私人密钥加密的信息只能使用公共密钥解密（这一功能应用与数字签名领域，我的私钥加密的数据，只有我的公钥可以解读，具体内容参考数字签名的信息）反之亦然，以确保您的信息安全。

**1. 加密算法之 MD5 算法**

MD5 的全称是 Message-Digest Algorithm 5，在 90 年代初由 MIT 的计算机科学实验室和 RSA Data Security Inc 发明，经 MD2、MD3 和 MD4 发展而来。

MD5 将任意长度的 “字节串” 变换成一个 128bit 的大整数，并且它是一个不可逆的字符串变换算法，换句话说就是，即使你看到源程序和算法描述，也无法将一个 MD5 的值变换回原始的字符串，从数学原理上说，是因为原始的字符串有无穷多个，这有点象不存在反函数的数学函数。 MD5 的典型应用是对一段 Message(字节串)产生 fingerprint(指纹)，以防止被“篡改”。举个例子，你将一段话写在一个叫 readme.txt 文件中，并对这个 readme.txt 产生一个 MD5 的值并记录在案，然后你可以传播这个文件给别人，别人如果修改了文件中的任何内容，你对这个文件重新计算 MD5 时就会发现。如果再有一个第三方的认证机构，用 MD5 还可以防止文件作者的“抵赖”，这就是所谓的数字签名应用。

MD5 还广泛用于加密和解密技术上，在很多操作系统中，用户的密码是以 MD5 值（或类似的其它算法）的方式保存的， 用户 Login 的时候，系统是把用户输入的密码计算成 MD5 值，然后再去和系统中保存的 MD5 值进行比较，而系统并不 “知道” 用户的密码是什么。在一些初始化处理后，MD5 以 512 位分组来处理输入文本，每一分组又划分为 16 个 32 位子分组。算法的输出由四个 32 位分组组成，将它们级联形成一个 128 位散列值。

首先填充消息使其长度恰好为一个比 512 位的倍数仅小 64 位的数。填充方法是附一个 1 在消息后面，后接所要求的多个 0，然后在其后附上 64 位的消息长度（填充前）。这两步的作用是使消息长度恰好是 512 位的整数倍（算法的其余部分要求如此），同时确保不同的消息在填充后不相同

四个 32 位变量初始化为：

A=0x01234567
B=0x89abcdef
C=0xfedcba98
D=0x76543210

它们称为链接变量（chaining variable）

接着进行算法的主循环，循环的次数是消息中 512 位消息分组的数目。 将上面四个变量复制到别外的变量中：A 到 a，B 到 b，C 到 c，D 到 d。

主循环有四轮（MD4 只有三轮），每轮很相拟。第一轮进行 16 次操作。每次操作对 a，b，c 和 d 中的其中三个作一次非线性函数运算，然后将所得结果加上第四个变量，文本的一个子分组和一个常数。再将所得结果向右环移一个不定的数，并加上 a，b，c 或 d 中之一。最后用该结果取代 a，b，c 或 d 中之一。
以一下是每次操作中用到的四个非线性函数（每轮一个）。
F(X,Y,Z)=(X&Y)|((~X)&Z)
G(X,Y,Z)=(X&Z)|(Y&(~Z))
H(X,Y,Z)=X^Y^Z
I(X,Y,Z)=Y^(X|(~Z))
(& 是与,| 是或,~ 是非,^ 是异或)
这些函数是这样设计的：如果 X、Y 和 Z 的对应位是独立和均匀的，那么结果的每一位也应是独立和均匀的。 
函数 F 是按逐位方式操作：如果 X，那么 Y，否则 Z。函数 H 是逐位奇偶操作符。 
设 Mj 表示消息的第 j 个子分组（从 0 到 15），<<< s 表示循环左移 s 位，则四种操作为： 
FF(a,b,c,d,Mj,s,ti) 表示 a=b+((a+(F(b,c,d)+Mj+ti)<<< s) 
GG(a,b,c,d,Mj,s,ti) 表示 a=b+((a+(G(b,c,d)+Mj+ti)<<< s) 
HH(a,b,c,d,Mj,s,ti) 表示 a=b+((a+(H(b,c,d)+Mj+ti)<<< s) 
II(a,b,c,d,Mj,s,ti) 表示 a=b+((a+(I(b,c,d)+Mj+ti)<<< s) 
这四轮（64 步）是： 
第一轮 
FF(a,b,c,d,M0,7,0xd76aa478) 
FF(d,a,b,c,M1,12,0xe8c7b756) 
FF(c,d,a,b,M2,17,0x242070db) 
FF(b,c,d,a,M3,22,0xc1bdceee) 
FF(a,b,c,d,M4,7,0xf57c0faf) 
FF(d,a,b,c,M5,12,0x4787c62a) 
FF(c,d,a,b,M6,17,0xa8304613) 
FF(b,c,d,a,M7,22,0xfd469501) 
FF(a,b,c,d,M8,7,0x698098d8) 
FF(d,a,b,c,M9,12,0x8b44f7af) 
FF(c,d,a,b,M10,17,0xffff5bb1) 
FF(b,c,d,a,M11,22,0x895cd7be) 
FF(a,b,c,d,M12,7,0x6b901122) 
FF(d,a,b,c,M13,12,0xfd987193) 
FF(c,d,a,b,M14,17,0xa679438e) 
FF(b,c,d,a,M15,22,0x49b40821) 
第二轮 
GG(a,b,c,d,M1,5,0xf61e2562) 
GG(d,a,b,c,M6,9,0xc040b340) 
GG(c,d,a,b,M11,14,0x265e5a51) 
GG(b,c,d,a,M0,20,0xe9b6c7aa) 
GG(a,b,c,d,M5,5,0xd62f105d) 
GG(d,a,b,c,M10,9,0x02441453) 
GG(c,d,a,b,M15,14,0xd8a1e681) 
GG(b,c,d,a,M4,20,0xe7d3fbc8) 
GG(a,b,c,d,M9,5,0x21e1cde6) 
GG(d,a,b,c,M14,9,0xc33707d6) 
GG(c,d,a,b,M3,14,0xf4d50d87) 
GG(b,c,d,a,M8,20,0x455a14ed) 
GG(a,b,c,d,M13,5,0xa9e3e905) 
GG(d,a,b,c,M2,9,0xfcefa3f8) 
GG(c,d,a,b,M7,14,0x676f02d9) 
GG(b,c,d,a,M12,20,0x8d2a4c8a) 
第三轮 
HH(a,b,c,d,M5,4,0xfffa3942) 
HH(d,a,b,c,M8,11,0x8771f681) 
HH(c,d,a,b,M11,16,0x6d9d6122) 
HH(b,c,d,a,M14,23,0xfde5380c) 
HH(a,b,c,d,M1,4,0xa4beea44) 
HH(d,a,b,c,M4,11,0x4bdecfa9) 
HH(c,d,a,b,M7,16,0xf6bb4b60) 
HH(b,c,d,a,M10,23,0xbebfbc70) 
HH(a,b,c,d,M13,4,0x289b7ec6) 
HH(d,a,b,c,M0,11,0xeaa127fa) 
HH(c,d,a,b,M3,16,0xd4ef3085) 
HH(b,c,d,a,M6,23,0x04881d05) 
HH(a,b,c,d,M9,4,0xd9d4d039) 
HH(d,a,b,c,M12,11,0xe6db99e5) 
HH(c,d,a,b,M15,16,0x1fa27cf8) 
HH(b,c,d,a,M2,23,0xc4ac5665) 
第四轮 
II(a,b,c,d,M0,6,0xf4292244) 
II(d,a,b,c,M7,10,0x432aff97) 
II(c,d,a,b,M14,15,0xab9423a7) 
II(b,c,d,a,M5,21,0xfc93a039) 
II(a,b,c,d,M12,6,0x655b59c3) 
II(d,a,b,c,M3,10,0x8f0ccc92) 
II(c,d,a,b,M10,15,0xffeff47d) 
II(b,c,d,a,M1,21,0x85845dd1) 
II(a,b,c,d,M8,6,0x6fa87e4f) 
II(d,a,b,c,M15,10,0xfe2ce6e0) 
II(c,d,a,b,M6,15,0xa3014314) 
II(b,c,d,a,M13,21,0x4e0811a1) 
II(a,b,c,d,M4,6,0xf7537e82) 
II(d,a,b,c,M11,10,0xbd3af235) 
II(c,d,a,b,M2,15,0x2ad7d2bb) 
II(b,c,d,a,M9,21,0xeb86d391) 
常数 ti 可以如下选择： 
在第 i 步中，ti 是 4294967296*abs(sin(i)) 的整数部分, i 的单位是弧度。 
(2 的 32 次方) 
所有这些完成之后，将 A，B，C，D 分别加上 a，b，c，d。然后用下一分组数据继续运行算法，最后的输出是 A，B，C 和 D 的级联。 
MD5 的安全性 

MD5 相对 MD4 所作的改进： 
1. 增加了第四轮. 
2. 每一步均有唯一的加法常数. 
3. 为减弱第二轮中函数 G 的对称性从 (X&Y)|(X&Z)|(Y&Z) 变为(X&Z)|(Y&(~Z)) 
4. 第一步加上了上一步的结果, 这将引起更快的雪崩效应. 
5. 改变了第二轮和第三轮中访问消息子分组的次序, 使其更不相似. 
6. 近似优化了每一轮中的循环左移位移量以实现更快的雪崩效应. 各轮的位移量互不相同.

**2. 加密算法之 DES 算法**

一、DES 算法 

　　美国国家标准局 1973 年开始研究除国防部外的其它部门的计算机系统的数据加密标准，于 1973 年 5 月 15 日和 1974 年 8 月 27 日先后两次向公众发出了征求加密算法的公告。加密算法要达到的目的（通常称为 DES 密码算法要求）主要为以下四点： ☆提供高质量的数据保护，防止数据未经授权的泄露和未被察觉的修改； 

☆具有相当高的复杂性，使得破译的开销超过可能获得的利益，同时又要便于理解和掌握； 

☆DES 密码体制的安全性应该不依赖于算法的保密，其安全性仅以加密密钥的保密为基础； 

☆实现经济，运行有效，并且适用于多种完全不同的应用。 

1977 年 1 月，美国政府颁布：采纳 IBM 公司设计的方案作为非机密数据的正式数据加密标准（DES?Data Encryption Standard）。 

　　目前在国内，随着三金工程尤其是金卡工程的启动，DES 算法在 POS、ATM、磁卡及智能卡（IC 卡）、加油站、高速公路收费站等领域被广泛应用，以此来实现关键数据的保密，如信用卡持卡人的 PIN 的加密传输，IC 卡与 POS 间的双向认证、金融交易数据包的 MAC 校验等，均用到 DES 算法。 
　　DES 算法的入口参数有三个：Key、Data、Mode。其中 Key 为 8 个字节共 64 位，是 DES 算法的工作密钥；Data 也为 8 个字节 64 位，是要被加密或被解密的数据；Mode 为 DES 的工作方式，有两种：加密或解密。 
　　DES 算法是这样工作的：如 Mode 为加密，则用 Key 去把数据 Data 进行加密， 生成 Data 的密码形式（64 位）作为 DES 的输出结果；如 Mode 为解密，则用 Key 去把密码形式的数据 Data 解密，还原为 Data 的明码形式（64 位）作为 DES 的输出结果。在通信网络的两端，双方约定一致的 Key，在通信的源点用 Key 对核心数据进行 DES 加密，然后以密码形式在公共通信网（如电话网）中传输到通信网络的终点，数据到达目的地后，用同样的 Key 对密码数据进行解密，便再现了明码形式的核心数据。这样，便保证了核心数据（如 PIN、MAC 等）在公共通信网中传输的安全性和可靠性。 
　　通过定期在通信网络的源端和目的端同时改用新的 Key，便能更进一步提高数据的保密性，这正是现在金融交易网络的流行做法。 
　　DES 算法详述 
　　DES 算法把 64 位的明文输入块变为 64 位的密文输出块，它所使用的密钥也是 64 位，整个算法的主流程图如下： 
其功能是把输入的 64 位数据块按位重新组合，并把输出分为 L0、R0 两部分，每部分各长 32 位，其置换规则见下表： 
58,50,12,34,26,18,10,2,60,52,44,36,28,20,12,4, 
　　62,54,46,38,30,22,14,6,64,56,48,40,32,24,16,8, 
　　57,49,41,33,25,17, 9,1,59,51,43,35,27,19,11,3, 
　　61,53,45,37,29,21,13,5,63,55,47,39,31,23,15,7, 
　　即将输入的第 58 位换到第一位，第 50 位换到第 2 位，...，依此类推，最后一位是原来的第 7 位。L0、R0 则是换位输出后的两部分，L0 是输出的左 32 位，R0 是右 32 位，例：设置换前的输入值为 D1D2D3......D64，则经过初始置换后的结果为：L0=D58D50...D8；R0=D57D49...D7。 
　　经过 16 次迭代运算后。得到 L16、R16，将此作为输入，进行逆置换，即得到密文输出。逆置换正好是初始置的逆运算，例如，第 1 位经过初始置换后，处于第 40 位，而通过逆置换，又将第 40 位换回到第 1 位，其逆置换规则如下表所示： 
　　40,8,48,16,56,24,64,32,39,7,47,15,55,23,63,31, 
　　38,6,46,14,54,22,62,30,37,5,45,13,53,21,61,29, 
　　36,4,44,12,52,20,60,28,35,3,43,11,51,19,59,27, 
　　34,2,42,10,50,18,58 26,33,1,41, 9,49,17,57,25, 
放大换位表 
　　32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10,11, 
　　12,13,12,13,14,15,16,17,16,17,18,19,20,21,20,21, 
　　22,23,24,25,24,25,26,27,28,29,28,29,30,31,32, 1, 
单纯换位表 
　　16,7,20,21,29,12,28,17, 1,15,23,26, 5,18,31,10, 
　　2,8,24,14,32,27, 3, 9,19,13,30, 6,22,11, 4,25, 
　　在 f(Ri,Ki) 算法描述图中，S1,S2...S8 为选择函数，其功能是把 6bit 数据变为 4bit 数据。下面给出选择函数 Si(i=1,2...... 的功能表： 
选择函数 Si 
S1: 
　　14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7, 
　　0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8, 
　　4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0, 
　　15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13, 
S2: 
　　15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10, 
　　3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5, 
　　0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15, 
　　13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9, 
S3: 
　　10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8, 
　　13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1, 
　　13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7, 
　　1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12, 
S4: 
　　7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15, 
　　13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9, 
　　10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4, 
　　3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14, 
S5: 
　　2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9, 
　　14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6, 
　　4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14, 
　　11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3, 
S6: 
　　12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11, 
　　10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8, 
　　9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6, 
　　4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13, 
S7: 
　　4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1, 
　　13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6, 
　　1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2, 
　　6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12, 
S8: 
　　13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7, 
　　1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2, 
　　7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8, 
　　2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11, 
在此以 S1 为例说明其功能，我们可以看到：在 S1 中，共有 4 行数据，命名为 0，1、2、3 行；每行有 16 列，命名为 0、1、2、3，......，14、15 列。 
　　现设输入为： D＝D1D2D3D4D5D6 
令：列＝D2D3D4D5 
　　行＝D1D6 
　　然后在 S1 表中查得对应的数，以 4 位二进制表示，此即为选择函数 S1 的输出。下面给出子密钥 Ki(48bit) 的生成算法 
　　从子密钥 Ki 的生成算法描述图中我们可以看到：初始 Key 值为 64 位，但 DES 算法规定，其中第 8、16、......64 位是奇偶校验位，不参与 DES 运算。故 Key 实际可用位数便只有 56 位。即：经过缩小选择换位表 1 的变换后，Key 的位数由 64 位变成了 56 位，此 56 位分为 C0、D0 两部分，各 28 位，然后分别进行第 1 次循环左移，得到 C1、D1，将 C1（28 位）、D1（28 位）合并得到 56 位，再经过缩小选择换位 2，从而便得到了密钥 K0（48 位）。依此类推，便可得到 K1、K2、......、K15，不过需要注意的是，16 次循环左移对应的左移位数要依据下述规则进行： 
循环左移位数 
1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1 
　　以上介绍了 DES 算法的加密过程。DES 算法的解密过程是一样的，区别仅仅在于第一次迭代时用子密钥 K15，第二次 K14、......，最后一次用 K0，算法本身并没有任何变化。 

二、DES 算法理论图解 

DES 的算法是对称的，既可用于加密又可用于解密。下图是它的算法粗框图。其具体运算过程有如下七步。 
＜缺：找到补上＞ 

三、DES 算法的应用误区　 

　　DES 算法具有极高安全性，到目前为止，除了用穷举搜索法对 DES 算法进行攻击外，还没有发现更有效的办法。而 56 位长的密钥的穷举空间为 256，这意味着如果一台计算机的速度是每一秒种检测一百万个密钥，则它搜索完全部密钥就需要将近 2285 年的时间，可见，这是难以实现的，当然，随着科学技术的发展，当出现超高速计算机后，我们可考虑把 DES 密钥的长度再增长一些，以此来达到更高的保密程度。 
　　由上述 DES 算法介绍我们可以看到：DES 算法中只用到 64 位密钥中的其中 56 位，而第 8、16、24、......64 位 8 个位并未参与 DES 运算，这一点，向我们提出了一个应用上的要求，即 DES 的安全性是基于除了 8，16，24，......64 位外的其余 56 位的组合变化 256 才得以保证的。因此，在实际应用中，我们应避开使用第 8，16，24，......64 位作为有效数据位，而使用其它的 56 位作为有效数据位，才能保证 DES 算法安全可靠地发挥作用。如果不了解这一点，把密钥 Key 的 8，16，24，..... .64 位作为有效数据使用，将不能保证 DES 加密数据的安全性，对运用 DES 来达到保密作用的系统产生数据被破译的危险，这正是 DES 算法在应用上的误区，留下了被人攻击、被人破译的极大隐患。

**3. 加密算法之 RSA 算法**

　　它是第一个既能用于数据加密也能用于数字签名的算法。它易于理解和操作，也很流行。算法的名字以发明者的名字命名：Ron Rivest, Adi Shamir 和 Leonard Adleman。但 RSA 的安全性一直未能得到理论上的证明。它经历了各种攻击，至今未被完全攻破。 

一、RSA 算法 : 

首先, 找出三个数, p, q, r, 
其中 p, q 是两个相异的质数, r 是与 (p-1)(q-1) 互质的数...... 
p, q, r 这三个数便是 private key 

接著, 找出 m, 使得 rm == 1 mod (p-1)(q-1)..... 
这个 m 一定存在, 因为 r 与 (p-1)(q-1) 互质, 用辗转相除法就可以得到了..... 
再来, 计算 n = pq....... 
m, n 这两个数便是 public key 

编码过程是, 若资料为 a, 将其看成是一个大整数, 假设 a < n.... 
如果 a >= n 的话, 就将 a 表成 s 进位 (s <= n, 通常取 s = 2^t), 
则每一位数均小於 n, 然後分段编码...... 
接下来, 计算 b == a^m mod n, (0 <= b < n), 
b 就是编码後的资料...... 

解码的过程是, 计算 c == b^r mod pq (0 <= c < pq), 
於是乎, 解码完毕...... 等会会证明 c 和 a 其实是相等的 

如果第三者进行窃听时, 他会得到几个数: m, n(=pq), b...... 
他如果要解码的话, 必须想办法得到 r...... 
所以, 他必须先对 n 作质因数分解......... 
要防止他分解, 最有效的方法是找两个非常的大质数 p, q, 
使第三者作因数分解时发生困难......... 

<定理> 
若 p, q 是相异质数, rm == 1 mod (p-1)(q-1), 
a 是任意一个正整数, b == a^m mod pq, c == b^r mod pq, 
则 c == a mod pq 

证明的过程, 会用到费马小定理, 叙述如下: 
m 是任一质数, n 是任一整数, 则 n^m == n mod m 
(换另一句话说, 如果 n 和 m 互质, 则 n^(m-1) == 1 mod m) 
运用一些基本的群论的知识, 就可以很容易地证出费马小定理的........ 

<证明> 
因为 rm == 1 mod (p-1)(q-1), 所以 rm = k(p-1)(q-1) + 1, 其中 k 是整数 
因为在 modulo 中是 preserve 乘法的 
(x == y mod z and u == v mod z => xu == yv mod z), 
所以, c == b^r == (a^m)^r == a^(rm) == a^(k(p-1)(q-1)+1) mod pq 

\1. 如果 a 不是 p 的倍数, 也不是 q 的倍数时, 
则 a^(p-1) == 1 mod p (费马小定理) => a^(k(p-1)(q-1)) == 1 mod p 
a^(q-1) == 1 mod q (费马小定理) => a^(k(p-1)(q-1)) == 1 mod q 
所以 p, q 均能整除 a^(k(p-1)(q-1)) - 1 => pq | a^(k(p-1)(q-1)) - 1 
即 a^(k(p-1)(q-1)) == 1 mod pq 
=> c == a^(k(p-1)(q-1)+1) == a mod pq 

\2. 如果 a 是 p 的倍数, 但不是 q 的倍数时, 
则 a^(q-1) == 1 mod q (费马小定理) 
=> a^(k(p-1)(q-1)) == 1 mod q 
=> c == a^(k(p-1)(q-1)+1) == a mod q 
=> q | c - a 
因 p | a 
=> c == a^(k(p-1)(q-1)+1) == 0 mod p 
=> p | c - a 
所以, pq | c - a => c == a mod pq 

\3. 如果 a 是 q 的倍数, 但不是 p 的倍数时, 证明同上 

\4. 如果 a 同时是 p 和 q 的倍数时, 
则 pq | a 
=> c == a^(k(p-1)(q-1)+1) == 0 mod pq 
=> pq | c - a 
=> c == a mod pq 
Q.E.D. 

这个定理说明 a 经过编码为 b 再经过解码为 c 时, a == c mod n (n = pq).... 
但我们在做编码解码时, 限制 0 <= a < n, 0 <= c < n, 
所以这就是说 a 等於 c, 所以这个过程确实能做到编码解码的功能..... 

二、RSA 的安全性 

RSA 的安全性依赖于大数分解，但是否等同于大数分解一直未能得到理论上的证明，因为没有证明破解 RSA 就一定需要作大数分解。假设存在一种无须分解大数的算法，那它肯定可以修改成为大数分解算法。目前， RSA 的一些变种算法已被证明等价于大数分解。不管怎样，分解 n 是最显然的攻击方法。现在，人们已能分解多个十进制位的大素数。因此，模数 n 必须选大一些，因具体适用情况而定。 

三、RSA 的速度 

由于进行的都是大数计算，使得 RSA 最快的情况也比 DES 慢上倍，无论是软件还是硬件实现。速度一直是 RSA 的缺陷。一般来说只用于少量数据加密。 

四、RSA 的选择密文攻击 

RSA 在选择密文攻击面前很脆弱。一般攻击者是将某一信息作一下伪装 (Blind)，让拥有私钥的实体签署。然后，经过计算就可得到它所想要的信息。实际上，攻击利用的都是同一个弱点，即存在这样一个事实：乘幂保留了输入的乘法结构： 

(XM)^d = X^d *M^d mod n 

前面已经提到，这个固有的问题来自于公钥密码系统的最有用的特征 -- 每个人都能使用公钥。但从算法上无法解决这一问题，主要措施有两条：一条是采用好的公钥协议，保证工作过程中实体不对其他实体任意产生的信息解密，不对自己一无所知的信息签名；另一条是决不对陌生人送来的随机文档签名，签名时首先使用 One-Way HashFunction 对文档作 HASH 处理，或同时使用不同的签名算法。在中提到了几种不同类型的攻击方法。 

五、RSA 的公共模数攻击 

若系统中共有一个模数，只是不同的人拥有不同的 e 和 d，系统将是危险的。最普遍的情况是同一信息用不同的公钥加密，这些公钥共模而且互质，那末该信息无需私钥就可得到恢复。设 P 为信息明文，两个加密密钥为 e1 和 e2，公共模数是 n，则： 

C1 = P^e1 mod n 

C2 = P^e2 mod n 

密码分析者知道 n、e1、e2、C1 和 C2，就能得到 P。 

因为 e1 和 e2 互质，故用 Euclidean 算法能找到 r 和 s，满足： 

r * e1 + s * e2 = 1 

假设 r 为负数，需再用 Euclidean 算法计算 C1^(-1)，则 

(C1^(-1) )^(-r) * C2^s = P mod n 

另外，还有其它几种利用公共模数攻击的方法。总之，如果知道给定模数的一对 e 和 d，一是有利于攻击者分解模数，一是有利于攻击者计算出其它成对的 e’和 d’，而无需分解模数。解决办法只有一个，那就是不要共享模数 n。 

RSA 的小指数攻击。 有一种提高 RSA 速度的建议是使公钥 e 取较小的值，这样会使加密变得易于实现，速度有 
所提高。但这样作是不安全的，对付办法就是 e 和 d 都取较大的值。 

RSA 算法是第一个能同时用于加密和数字签名的算法，也易于理解和操作。RSA 是被研究得最广泛的公钥算法，从提出到现在已近二十年，经历了各种攻击的考验，逐渐为人们接受，普遍认为是目前最优秀的公钥方案之一。RSA 的安全性依赖于大数的因子分解，但并没有从理论上证明破译 RSA 的难度与大数分解难度等价。即 RSA 的重大缺陷是无法从理论上把握它的保密性能如何，而且密码学界多数人士倾向于因子分解不是 NPC 问题。 RSA 的缺点主要有：A) 产生密钥很麻烦，受到素数产生技术的限制，因而难以做到一次一密。B) 分组长度太大，为保证安全性，n 至少也要 600 bits 以上，使运算代价很高，尤其是速度较慢，较对称密码算法慢几个数量级；且随着大数分解技术的发展，这个长度还在增加，不利于数据格式的标准化。目前，SET(Secure Electronic Transaction) 协议中要求 CA 采用比特长的密钥，其他实体使用比特的密钥。